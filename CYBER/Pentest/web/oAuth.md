# flow 
for the flow we use a server that can authenticate .
we send to the server a client_id that allow the server to check the authority

# state parameter & PKCE

to be sure that the client only send the code and no other one we can use a state parameter .
with this parameter we guarantee that the client that receive the code is the only one that send ask for data. 
The state is given back by the OAuth2 server in the redirected url, so the client app can verify that the request to open the authorization page was indeed triggered by itself.

The code_challenge is not given back by the OAuth2 server, but the client app must send the belonging code_verifier with the next request to exchange the authorization code for a token. The OAuth2 server can then be sure that it is the same client app which did the first request to open the authorization page.

Even if an attacker listened to the first request and the following redirect, (s)he cannot know the code_verifier, it is never sent over the wire. This makes it impossible to (mis)use the redirect and impersonate the client to get the token.

So yes both are required, the state makes the link between the open-authorization-page-request and the redirect, and the code_challenge makes the link between open-authorization-page-request and exchange-code-for-token-request.

THE STATE PARAMETER IS STORE IN THE LOCALSTORAGE . 
not need to be overprotected but have to be in client side. 

# Pentest

## find oauth type :
to find the toolkit to authorize oauth flow . 

- we can see the path of the oauth flow : Django OAuth Toolkit typically follows the pattern /oauth/authorize/ and /oauth/token/
- Error Messages
- Source Code Analysis: if we have access to the code
- HTTP Request : check the header and other to find the server type .

## find token : 
redirect_uri : the redirect uri can be used to get the token . if it's not well protected we can override this .

## no state parameter 


